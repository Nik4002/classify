use crate::utilities::breaks_to_classification;
use crate::utilities::Classification;

/// Returns a Classification object following the Quantile Breaks algorithm given the desired number of bins and one-dimensional f64 data (note: the maximum number of bins generated by this algorithm is the number of unique values in the dataset)
///
/// # Arguments
///
/// * `num_bins` - A reference to an integer (u64) representing the desired number of bins
/// * `data` - A reference to a vector of unsorted data points (f64) to generate breaks for
///
/// # Examples
///
/// ```
/// use classify::get_quantile_classification;
/// use classify::{Classification, Bin};
///
/// let data: Vec<f64> = vec![1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0];
/// let num_bins = 3;
///
/// let result: Classification = get_quantile_classification(&num_bins, &data);
/// let expected: Classification = Classification {bins: vec![
///     Bin{bin_start: 1.0, bin_end: 4.0, count: 3},
///     Bin{bin_start: 4.0, bin_end: 7.0, count: 3},
///     Bin{bin_start: 7.0, bin_end: 9.0, count: 3}]
/// };
///
/// assert!(result == expected);
/// ```
pub fn get_quantile_classification(num_bins: &usize, data: &Vec<f64>) -> Classification {
    let breaks: Vec<f64> = get_quantile_breaks(num_bins, data);
    breaks_to_classification(&breaks, data)
}

/// Returns a vector of breaks generated through the Quantile Breaks algorithm given the desired number of bins and a dataset (note: the maximum number of bins generated by this algorithm is the number of unique values in the dataset)
///
/// # Arguments
///
/// * `num_bins` - The desired number of bins
/// * `data` - A reference to a vector of unsorted data points (f64) to generate breaks for
///
/// # Examples
///
/// ```
/// use classify::get_quantile_breaks;
///
/// let data: Vec<f64> = vec![1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0];
/// let num_bins = 3;
///
/// let result: Vec<f64> = get_quantile_breaks(&num_bins, &data);
///
/// assert_eq!(result, vec![4.0, 7.0]);
/// ```
pub fn get_quantile_breaks(num_bins: &usize, data: &Vec<f64>) -> Vec<f64> {
    if *num_bins == 0 || *num_bins == 1 {
        let result: Vec<f64> = vec![];
        return result;
    }

    let num_vals = data.len();

    let mut unique_data: Vec<f64> = vec![];
    for item in data.iter().take(num_vals) {
        unique_data.push(*item);
    }
    unique_data.sort_by(|a, b| a.partial_cmp(b).unwrap());
    unique_data.dedup();

    let num_unique_vals = unique_data.len();
    let true_num_bins = *std::cmp::min(&num_unique_vals, num_bins);

    let mut breaks: Vec<f64> = vec![];

    for i in 1..true_num_bins {
        breaks.push(unique_data[((i * num_unique_vals) as f64 / (true_num_bins) as f64) as usize]);
    }

    breaks
}
